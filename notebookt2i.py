# -*- coding: utf-8 -*-
"""NotebookT2I.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/125UL9RDHXyr2tNQ0Pyg9Ctgy2RjfOfV8
"""

# @title Environment WUI - MultiDiffusion

# @title Install { vertical-output: true, display-mode: "form" }
!pip install -q diffusers["torch"] transformers --upgrade
!pip install -q accelerate
!pip install -q git+https://github.com/huggingface/diffusers

# @title Default title text
import torch
from diffusers import StableDiffusionPipeline
from diffusers import DPMSolverMultistepScheduler

pipe = StableDiffusionPipeline.from_pretrained("frankjoshua/toonyou_beta6", torch_dtype=torch.float16)
pipe = pipe.to("cuda")
pipe.safety_checker = None
pipe.scheduler = DPMSolverMultistepScheduler.from_config(pipe.scheduler.config)

torch.cuda.empty_cache()
print("VRAM Erased")

# @title Default title text { vertical-output: true }
from IPython.display import display, Image, HTML
import os
import string
import random
import datetime
from google.colab import drive
import ipywidgets as widgets

from diffusers import DPMSolverMultistepScheduler, LMSDiscreteScheduler

# Crear el pipeline de difusión estable
pipe = pipe.to("cuda")
pipe.safety_checker = None
pipe.scheduler = DPMSolverMultistepScheduler.from_config(pipe.scheduler.config)

# Obtener el directorio actual
current_dir = "/content"
images_dir_default = os.path.join(current_dir, "generated_images")
images_dir_drive = "/content/drive/MyDrive/Notebook"
os.makedirs(images_dir_default, exist_ok=True)

# Tamaño base de la imagen
BASE_HEIGHT = 800
BASE_WIDTH = 600

# Funciones auxiliares
def nearest_multiple_of_eight(x):
    return int(8 * round(float(x) / 8))

def mount_drive():
    try:
        if not os.path.exists('/content/drive/'):
            drive.mount('/content/drive', force_remount=True)
    except Exception as e:
        print("Error al montar Google Drive:", e)

def generate_unique_code():
    characters = string.ascii_uppercase + string.digits
    code = ''.join(random.choice(characters) for _ in range(6))
    return code

# Estilo CSS para los campos de texto
textarea_style = {'description_width': 'initial',
                  'margin': '0px 0px 0px 0px',
                  'width': '100%',
                  'height': '75px',
                  'padding': '5px 5px'}

# Crear widgets para los parámetros
prompt_input = widgets.Textarea(value="masterpiece, best quality, ultra-detailed, blue theme, md, scenery, light particles, (1girl:1.4), solo, upper body, looking at viewer, portrait, clouds, hyper detailed,", description="Prompt:", layout=widgets.Layout(width='100%', height='100px'))
neg_input = widgets.Textarea(value="(worst quality, low quality), EasyNegativeV2, ng_deepnegative_v1_75t, bad-hands-5,", description="Negative:", layout=widgets.Layout(width='100%', height='100px'))
num_images_input = widgets.IntSlider(value=1, min=1, max=10, step=1, description="Images:")  # Aquí se crea el widget num_images_input

# Aplicar estilo CSS a los campos de texto
prompt_input.style = textarea_style
neg_input.style = textarea_style

# Función para ocultar o mostrar el prompt
def hide_prompt(change):
    prompt_input.layout.display = 'none' if change.new else 'block'

# Función para ocultar o mostrar el negative
def hide_negative(change):
    neg_input.layout.display = 'none' if change.new else 'block'

# Vincular la función para ocultar o mostrar el prompt al checkbox
hide_prompt_checkbox = widgets.Checkbox(value=False, description='Hide Prompt')
hide_prompt_checkbox.observe(hide_prompt, names='value')

# Vincular la función para ocultar o mostrar el negative al checkbox
hide_neg_checkbox = widgets.Checkbox(value=False, description='Hide Negative')
hide_neg_checkbox.observe(hide_negative, names='value')

# Función para generar imágenes
def generate_images(button):
    output_image.clear_output()

    if sampler_name_input.value == "DPMSolverMultistepScheduler":
        pipe.scheduler = DPMSolverMultistepScheduler.from_config(pipe.scheduler.config)
    elif sampler_name_input.value == "LMSDiscreteScheduler":
        pipe.scheduler = LMSDiscreteScheduler.from_config(pipe.scheduler.config)

    # Obtener los valores de altura y anchura
    height = nearest_multiple_of_eight(height_input.value)
    width = nearest_multiple_of_eight(width_input.value)

    # Calcular el factor de escala
    scale_factor_h = height / BASE_HEIGHT
    scale_factor_w = width / BASE_WIDTH

    # Calcular el nuevo tamaño de la imagen
    new_height = int(BASE_HEIGHT * scale_factor_h)
    new_width = int(BASE_WIDTH * scale_factor_w)

    # Ajustar el tamaño base
    pipe.height = new_height
    pipe.width = new_width

    # Montar Google Drive si se selecciona la opción de guardar en Drive
    if save_location_input.value == "drive/MyDrive/Notebook":
        mount_drive()

    # Generar las imágenes con el nuevo tamaño y la cantidad especificada
    images = pipe(prompt_input.value, num_images_per_prompt=num_images_input.value, height=new_height, width=new_width, num_inference_steps=steps_input.value, guidance_scale=guidance_input.value, negative_prompt=neg_input.value, clip_skip=skip_input.value).images

    # Mostrar las imágenes generadas
    with output_image:
        for i, img in enumerate(images):
            filename = f"image_{i}_{generate_unique_code()}.png"
            if save_location_input.value == "content/generated_images":
                img_path = os.path.join(images_dir_default, filename)
            else:
                notebook_dir = os.path.join(images_dir_drive, "Notebook")
                os.makedirs(notebook_dir, exist_ok=True)
                img_path = os.path.join(notebook_dir, filename)
            img.save(img_path)
            creation_date = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            display(Image(filename=img_path))
            display(HTML(f"<p style='font-size:14px;'>Created on: {creation_date}<br>Filename: {filename}<br>Saved at: {img_path}</p>"))

    # Limpiar VRAM después de generar imágenes
    import torch
    torch.cuda.empty_cache()

# Crear widgets para los parámetros
height_input = widgets.IntSlider(value=800, min=100, max=2000, step=8, description="Height:")
width_input = widgets.IntSlider(value=600, min=100, max=2000, step=8, description="Width:")
steps_input = widgets.IntSlider(value=25, min=1, max=100, step=1, description="Steps:")
guidance_input = widgets.FloatSlider(value=7, min=0, max=10, step=0.1, description="CFG scale:")
sampler_name_input = widgets.Dropdown(options=["DPMSolverMultistepScheduler", "LMSDiscreteScheduler"], value="DPMSolverMultistepScheduler", description="Sampler:")
skip_input = widgets.IntSlider(value=1, min=1, max=10, step=1, description="Clip Skip:")
save_location_input = widgets.Dropdown(options=["content/generated_images", "drive/MyDrive/Notebook"], value="content/generated_images", description="Save Location:")
generate_button = widgets.Button(description="Generate Images", button_style='success')

# Establecer el estilo CSS para el botón "Generate Images"
generate_button.style.button_color = 'blue'
generate_button.style.font_weight = 'bold'
generate_button.style.font_size = 'large'
generate_button.style.color = 'white'

# Widget de salida para mostrar la imagen generada
output_image = widgets.Output()

# Vincular la función de generación al botón de generación
generate_button.on_click(generate_images)

# Organizar los widgets en secciones
form_layout = widgets.Layout(display='flex', flex_flow='column', align_items='stretch', border='solid', width='50%')

prompt_section = widgets.VBox([prompt_input, hide_prompt_checkbox], layout=form_layout)
neg_section = widgets.VBox([neg_input, hide_neg_checkbox], layout=form_layout)
size_section = widgets.VBox([height_input, width_input, num_images_input], layout=form_layout)  # Se agrega num_images_input a size_section
steps_section = widgets.VBox([steps_input, skip_input, guidance_input], layout=form_layout)
config_section = widgets.VBox([sampler_name_input, save_location_input], layout=form_layout)
button_section = widgets.VBox([generate_button], layout=form_layout)

# Mostrar los widgets
display(widgets.HBox([prompt_section, neg_section]))
display(widgets.HBox([size_section, steps_section, config_section]))
display(button_section)
display(output_image)